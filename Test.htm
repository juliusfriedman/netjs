<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Javascript Generic List Implementation</title>

    <script type="text/javascript" src="GenericList.js"></script>
    <script type="text/javascript" src="Cast.js"></script>
    <script type="text/javascript" src="Reflection.js"></script>

    <script type="text/javascript">

        function Car(make, model)
        {
            this.make = make;
            this.model = model;
        }

        function except(ex) { alert(+ex ? 'Message: ' + ex : this.caller.toString()); }

        function Verify(result, expected){
            if(!result || !isNaN(result)) return result === expected;
            if(expected.length){
                result = Object.keys(result);
                expected = Object.keys(expected);
                if(result.length !== expected.length) return false;
            }
            try{ result.forEach(function(o, i){ if(o !== expected[i]) throw Error; }); }
            catch(e) { return false;}
            return true;
        }

        function TestReflection() {
            var myList = new List(),
                test = Reflection.getArguments(myList.Add);
            if (!Verify(test, ['object'])) except('Wrong Return');

            test = myList.Reverse.getArguments();
            if (!Verify(test, ['index', 'count'])) except('Wrong Return');
        }

        function TestCast() {
            var test = new myClass(),
            anotherTest = new anotherClass(),
            composed = test + anotherTest,
            yaComposed = test.cast(Number, function () {
                return this + anotherTest
            });
            if (!Verify(composed, 1)) except('Wrong Return');  //Because both types overload to return numbers which should equal 1 by default 0 + 1 = 1;
            if(!Verify(yaComposed, 1)) except('Wrong Return'); //Because test Casted as a Number return 0 added to the derived class which overloads + to return a number which is default 1;
            
            //Should fail because anotherClass hides the function cast
            try {
                yaCComposed = anotherTest.cast(Number, function () {
                    return this + test;
                });                
            } catch (ex) { console.log(ex); }

            //Should not fail because anotherClass is an instance of myClass
            t = test.cast(anotherClass, function () {
                return this + anotherTest
            });

            if (!Verify(t, 2)) except('Wrong Return');  //Because test is casted to anotherClass which gives it a default value of 1 and 1 + 1 = 2;

            //Should fail because anotherClass hides the function cast
            try {
                tt = anotherTest.cast(myClass, function () {
                    return this + test;
                });
            } catch (ex) { console.log(ex); }

            //Should fail because baseClass it abstract
            try { new baseClass(); }
            catch (e) {console.log(e); }

        }

        function TestList() {

            var myList = new List();
            myList.Add(new Car("Honda", "Civic"));
            myList.Add(new Car("Nissan", "Sentra"));
            myList.Add(new Car("Honda", "Cr-V"));
            myList.Add(new Car("Honda", "Cr-V"));

            //This will retrieve the 0th member from the List
            var testGetter = myList[0]; // Car{make:'Honda',model:'Civic'}

            try {
                //This will produce an exception
                var testGetterException = myList[9];
            }
            catch (e) {
                //e = "index parameter out of range in List.Get"
            }

            var selList = myList.Where("make == 'Honda'").OrderByDescending("model").Distinct(); //2 in Count
            var anotherList = myList.Where(function () { return this.make == 'Honda' }).OrderByDescending("model").Distinct(); //2 in Count
            var yetAnotherList = myList.Where(function (c) { return c.make == 'Honda' }).OrderByDescending("model").Distinct(); //2 in Count
            var finalList = myList.Where(function () { return make == 'Honda' }).OrderByDescending("model").Distinct(); //0 in Count because make is not quantified

            if (selList.Count() !== 2 || anotherList.Count() !== 2 || yetAnotherList.Count() !== 2 || finalList.Count() !== 0) alert('Bug');

            var outputString = '';
            for (var index = 0; index < selList.Count(); index++)
                outputString += selList.ElementAt(index).model + '\r\n';

            var outputElement = document.getElementById('output');
            if (outputElement)
                outputElement.innerText = outputString;
        }

        function init()
        {
            try
            {


                TestList();

                TestReflection();

                TestCast();

                
            }
            catch(ex)
            {
                alert('The following error occurred: ' + ex);
            }
        }
    
    </script>

</head>
<body onload="init()">
    <h1 id="output" runat="server" />
</body>
</html>
